package main

var Depth float
var RotateTextureZInterval float
var ColorsByDepth [8]vec4

func hash(p vec2, seed float) float {
	return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 * seed)
}

func grayValue(clr vec3) float {
	return 0.299 * clr.r + 0.587 * clr.g + 0.114 * clr.b
}

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
	const (
		ratio = 9. / 16.
		pi = 3.1415927
		texturesCount = 3.
	)

	origin, size := imageSrcRegionOnTexture()
    p := (texCoord-origin)/size * 2. - 1.
	p.y *= float(ratio)

    a := atan2(p.y, p.x)
	r := length(p)
    uv := vec2(0.3/r + Depth, a/pi)
	uv2 := vec2(uv.x, atan2(p.y, abs(p.x))/pi)
	uv2 = mod(uv2 * size, size)
	// Surface texture
	var sclr vec3
	index := mod(uv.x / RotateTextureZInterval, texturesCount)
	if index < 1. {
		sclr = imageSrc1UnsafeAt(origin+uv2).rgb
	} else if index < 2. {
		sclr = imageSrc2UnsafeAt(origin+uv2).rgb
	} else {
		sclr = imageSrc3UnsafeAt(origin+uv2).rgb
	}

	// Gray it before mixing with color
	sclr = vec3(grayValue(sclr))
	
	// Magnet color
	cmpl := imageSrc0UnsafeAt(
		origin+vec2(uv.x/imageSrcTextureSize().x, 0.),
	).rgb

	// clr = (clr*cmpl+clr)/2.//(clr+cmpl*0.5)/2.
	clr := (sclr+cmpl*sclr)/2.
	// clr = clamp(clr, vec3(0.), vec3(1.))

    return vec4(clr*r, 1.)
}